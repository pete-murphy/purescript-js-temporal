<!DOCTYPE html><html lang="en" class="__variable_7a8582 __variable_c4141f"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4de1fea1a954a5b6-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/c0984d28def8350c-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/c856374feb52eee1-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/imgs/avatar.png"/><link rel="stylesheet" href="/_next/static/css/7b1ec96690a919f5.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-7ae3dcd10d4eca79.js"/><script src="/_next/static/chunks/4bd1b696-b6aeba0e79b45328.js" async=""></script><script src="/_next/static/chunks/517-df527035a0bd2302.js" async=""></script><script src="/_next/static/chunks/main-app-5b0f815b1f9f1cb4.js" async=""></script><script src="/_next/static/chunks/app/layout-67aeb5fe06fab443.js" async=""></script><script src="/_next/static/chunks/285-d25152c281cc32f4.js" async=""></script><script src="/_next/static/chunks/app/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D/not-found-a959423e336829e2.js" async=""></script><script src="/_next/static/chunks/870fdd6f-7cfe8e21d14519e7.js" async=""></script><script src="/_next/static/chunks/69b09407-cf68df3e43abe457.js" async=""></script><script src="/_next/static/chunks/173-63dfeb1b55f51a11.js" async=""></script><script src="/_next/static/chunks/291-b0de5d611e0618a1.js" async=""></script><script src="/_next/static/chunks/app/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D/page-35c7a06c65b3d5a6.js" async=""></script><meta name="next-size-adjust" content=""/><title>Haskell for all: Module organization guidelines for Haskell projects</title><meta name="description" content="Tips and tricks for how to organize a Haskell project"/><link rel="alternate" type="application/rss+xml" title="Haskell for all" href="https://haskellforall.com/rss.xml"/><meta property="og:title" content="Module organization guidelines for Haskell projects"/><meta property="og:description" content="Tips and tricks for how to organize a Haskell project"/><meta property="og:image" content="https://haskellforall.com/imgs/logo.jpg"/><meta property="og:image:alt" content="Module organization guidelines for Haskell projects"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Module organization guidelines for Haskell projects"/><meta name="twitter:description" content="Tips and tricks for how to organize a Haskell project"/><meta name="twitter:image" content="https://haskellforall.com/imgs/logo.jpg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="24x24"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><div class="article"><h1 class="header"><a href="/">Haskell for all</a><span class="socials"><a href="https://github.com/Gabriella439"><svg data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github github" role="img" viewBox="0 0 512 512" aria-hidden="true"><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM252.8 8c-138.7 0-244.8 105.3-244.8 244 0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1 100-33.2 167.8-128.1 167.8-239 0-138.7-112.5-244-251.2-244zM105.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="/rss.xml"><svg data-prefix="fas" data-icon="rss" class="svg-inline--fa fa-rss rss" role="img" viewBox="0 0 448 512" aria-hidden="true"><path fill="currentColor" d="M0 64c0-17.7 14.3-32 32-32 229.8 0 416 186.2 416 416 0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96 14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0 64 64 0 1 1 -128 0zM32 160c159.1 0 288 128.9 288 288 0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a><a href="mailto:GenuineGabriella@gmail.com"><img class="svg-inline--fa logo" src="/imgs/avatar.png"/></a></span></h1><div class="stack"><hr/><div><h6>Wednesday, May 19, 2021</h6><h2><a href="">Module organization guidelines for Haskell projects</a></h2></div><div class="post"><p>This post collects a random assortment of guidelines I commonly share for how to organize Haskell projects.</p>
<h4>Organize modules “vertically”, not “horizontally”</h4>
<p>The glib summary of this rule is: don’t create a “Types” or “Constants” module.</p>
<p>“Vertically” organized modules are modules that group related functionality within the same module. For example, vertically-oriented modules for a simple interpreter might be:</p>
<ul>
<li>
<p>A <code>Syntax</code> module</p>
<p>… which contains the concrete syntax tree type and utilities for traversing, viewing, or editing that tree.</p>
</li>
<li>
<p>A <code>Parsing</code> module</p>
<p>… which contains (or imports/re-exports) the parser type, a parser for the syntax tree, and error messages specific to parsing.</p>
</li>
<li>
<p>An <code>Infer</code> module</p>
<p>… which contains the the type inference logic, exception types, and error messages specific to type-checking.</p>
</li>
<li>
<p>An <code>Evaluation</code> module</p>
<p>… which logic for evaluating an expression, including possibly a separate data structure for a fully-evaluated abstract syntax tree.</p>
</li>
<li>
<p>A <code>Pretty</code> module</p>
<p>… which specifies how to pretty-print or otherwise format expressions for display.</p>
</li>
</ul>
<p>“Horizontally” organized modules mean that you organize code into modules based on which language features or imports the code relies upon. For example, horizontally-oriented modules for the same interpreter might be:</p>
<ul>
<li>
<p>A <code>Types</code> module</p>
<p>… which contains almost all types, including the concrete syntax tree, abstract syntax tree, parsing-related types, and exception types.</p>
</li>
<li>
<p>A <code>Lib</code> module</p>
<p>… which contains almost all functions, including the parsers, type inference code, evaluator, and prettyprinter.</p>
</li>
<li>
<p>A <code>Constants</code> module</p>
<p>… which contains almost all constants (including all error messages, timeouts, and help text).</p>
</li>
<li>
<p>An <code>App</code> module</p>
<p>… which contains the <code>main</code> entry point for the program.</p>
</li>
</ul>
<p>There are a few reasons I prefer vertical module organization over horizontal module organization:</p>
<ul>
<li>
<p>Vertically-organized modules are easier to split into smaller packages</p>
<p>For example, in a vertically-organized project I could separate out the <code>Syntax</code>, <code>Parser</code>, and <code>Pretty</code> modules into a separate standalone package, which could be used by other people to create an automatic code formatter for my language without having to depend on the type-checking or evaluation logic.</p>
<p>Conversely, there would be little benefit in separating out a <code>Types</code> module from the equivalent horizontally-organized package. Typically, horizontal modules are so tightly coupled to one another that no subset of the modules is useful in isolation.</p>
<p>The separability of vertical modules is an even bigger feature for proprietary projects that aspire to eventually open source their work. Vertically-organized projects are easier to open source a few modules at a time while keeping the proprietary pieces internal.</p>
</li>
<li>
<p>Vertically-organized modules tend to promote more granular and incremental build graphs</p>
<p>In a horizontally-organized project, each new type you add to the <code>Types</code> module forces a rebuild of the entire package. In a vertically-organized project, if I completely rewrite the type-checking logic then only other modules that depend on type-checking will rebuild (and typically very few depend on type-checking).</p>
</li>
<li>
<p>Vertically-organized modules tend to group related changes</p>
<p>A common issue in a horizontally-organized project is that every change touches almost every module, making new contributions harder and making related functionality more difficult to discover. In a vertically-organized project related changes tend to fall within the same module.</p>
</li>
</ul>
<h4>Naming conventions</h4>
<p>I like to use the convention that the default module to import is the same as the package name, except replacing <code>-</code> with <code>.</code> and capitalizing words.</p>
<p>For example, if your package name is <code>foo-bar-baz</code>, then the default module the user imports to use your package is <code>Foo.Bar.Baz</code>.</p>
<p>Packages following this module naming convention typically do not have module names beginning with <code>Control.</code> or <code>Data.</code> prefixes (unless the package name happens to begin with a <code>control-</code> or <code>data-</code> prefix).</p>
<p>There are a few reasons I suggest this convention:</p>
<ul>
<li>
<p>Users can easily infer which module to import from the package name</p>
</li>
<li>
<p>It tends to lead to shorter module names</p>
<p>For example, the <code>prettyprinter</code> package recently switched to this idiom, which changed the default import from <code>Data.Text.Prettyprint.Doc</code> to <code>Prettyprinter</code>.</p>
</li>
<li>
<p>It reduces module naming clashes between packages</p>
<p>The reasoning is that you are already claiming global namespace when naming a package, so should why not also globally reserve the module of the same name, too?</p>
<p>However, this won’t completely eliminate the potential for name clashes for other non-default modules that your package exports.</p>
</li>
</ul>
<h4>The “God” library stanza</h4>
<p>This is a tip <strong>for proprietary projects only</strong>: put all of your project’s code into one giant library stanza in your <code>.cabal</code> file, including the entrypoint logic (like your command-line interface), tests, and benchmarks. Then every other stanza in the <code>.cabal</code> file (i.e. the executables, test suites, and benchmarks) should just be a thin wrapper around something exported from one of your “library” modules.</p>
<p>For example, suppose that your package is named <code>foo</code> which builds an executable named <code>bar</code>. Your <code>foo.cabal</code> file would look like this (with only the relevant parts shown):</p>
<pre><code>name: foo
…

library
  hs-source-dirs: src
  exposed-modules:
    Foo.Bar
  …

executable bar
  hs-source-dirs: bar
  main-is: Main.hs
  …
</code></pre>
<p>… where <code>src/Foo/Bar.hs</code> would look like this:</p>
<pre class="shiki catppuccin-frappe" style="background-color:#303446;color:#c6d0f5" tabindex="0"><code><span class="line"><span style="color:#737994;font-style:italic">-- ./src/Foo/Bar.hs</span></span>
<span class="line"><span style="color:#CA9EE6">module</span><span style="color:#E5C890"> Foo.Bar</span><span style="color:#CA9EE6"> where</span></span>
<span class="line"></span>
<span class="line"><span style="color:#81C8BE">…</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8CAAEE;font-style:italic">main</span><span style="color:#81C8BE"> ::</span><span style="color:#CA9EE6"> IO</span><span style="color:#949CBB"> ()</span></span>
<span class="line"><span style="color:#C6D0F5">main </span><span style="color:#81C8BE">=</span><span style="color:#81C8BE"> …</span><span style="color:#737994;font-style:italic"> -- Your real `main` goes here</span></span></code></pre>
<p>… and <code>bar/Main.hs</code> is a trivial wrapper around <code>Foo.Bar.main</code>:</p>
<pre class="shiki catppuccin-frappe" style="background-color:#303446;color:#c6d0f5" tabindex="0"><code><span class="line"><span style="color:#737994;font-style:italic">-- ./bar/Main.hs</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CA9EE6">module</span><span style="color:#E5C890"> Main</span><span style="color:#CA9EE6"> where</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CA9EE6">import</span><span style="color:#CA9EE6"> qualified</span><span style="color:#E5C890"> Foo.Bar</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8CAAEE;font-style:italic">main</span><span style="color:#81C8BE"> ::</span><span style="color:#CA9EE6"> IO</span><span style="color:#949CBB"> ()</span></span>
<span class="line"><span style="color:#C6D0F5">main </span><span style="color:#81C8BE">=</span><span style="color:#E5C890"> Foo.Bar.</span><span style="color:#C6D0F5">main</span></span></code></pre>
<p>This tip specifically works around <code>cabal repl</code>’s poor support for handling changes that span multiple project stanzas (both <code>cabal v1-repl</code> and <code>cabal v2-repl</code> appear to have the problem).</p>
<p>To illustrate the issue, suppose that you use <code>cabal repl</code> to load the executable logic for the project like this:</p>
<pre class="shiki catppuccin-frappe" style="background-color:#303446;color:#c6d0f5" tabindex="0"><code><span class="line"><span style="color:#8CAAEE;font-style:italic">$</span><span style="color:#A6D189"> cabal</span><span style="color:#A6D189"> repl</span><span style="color:#A6D189"> exe:bar</span></span>
<span class="line"><span style="color:#8CAAEE;font-style:italic">…</span></span>
<span class="line"><span style="color:#81C8BE">*</span><span style="color:#C6D0F5">Main</span><span style="color:#81C8BE">&gt;</span></span></code></pre>
<p>Now if you change the <code>Foo.Bar</code> module and <code>:reload</code> the REPL, the REPL will not reflect the changes you made. This is a pain whenever you need to test changes that span your library and an executable, your library and a test suite, or your library and a benchmark.</p>
<p>Also, if you load an executable / test suite / benchmark into the REPL that depends on a separate library stanza then <code>cabal repl</code> will force you to generate object code for the library stanza, which is slow. Contrast that with using <code>cabal repl</code> to only load the library stanza, which will be faster because it won’t generate object code.</p>
<p>Moreover, <code>ghcid</code> uses <code>cabal repl</code> to power its fast type-checking loop, which means that <code>ghcid</code> also does not work well if you need to quickly switch between changes to the library stanza and other project stanzas.</p>
<p>The fix to all of these problems is: put all of your project’s logic into the library stanza and use only the library stanza as basis for your interactive development. Everything else (your executables, your test suites, and your benchmarks) is just a trivial wrapper around something exported from the library.</p>
<p>I don’t recommend this solution for open source projects, though. If you do this for a public package then your end users will hate you because your package’s library section will depend on test packages or benchmarking packages that can’t be disabled. In contrast, proprietary codebases rarely care about gratuitous dependencies (in my experience).</p>
<h4>Conclusion</h4>
<p>Those are all of the tips I can think of at the moment. Leave a comment if you think I missed another common practice.</p></div><hr/><div class="license center">Copyright © 2021 <a href="mailto:GenuineGabriella@gmail.com">Gabriella Gonzalez</a>. This work is licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div></div></div><script src="/_next/static/chunks/webpack-7ae3dcd10d4eca79.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[2479,[\"177\",\"static/chunks/app/layout-67aeb5fe06fab443.js\"],\"default\"]\n3:I[5244,[],\"\"]\n4:I[3866,[],\"\"]\n5:I[1961,[\"285\",\"static/chunks/285-d25152c281cc32f4.js\",\"768\",\"static/chunks/app/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D/not-found-a959423e336829e2.js\"],\"default\"]\n7:I[6213,[],\"OutletBoundary\"]\n9:I[6213,[],\"MetadataBoundary\"]\nb:I[6213,[],\"ViewportBoundary\"]\nd:I[4835,[],\"\"]\n:HL[\"/_next/static/media/4de1fea1a954a5b6-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/c0984d28def8350c-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/c856374feb52eee1-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/7b1ec96690a919f5.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"URi3zFfbrSATOhY4M2NDh\",\"p\":\"\",\"c\":[\"\",\"2021\",\"05\",\"module-organization-guidelines-for\"],\"i\":false,\"f\":[[[\"\",{\"children\":[[\"year\",\"2021\",\"d\"],{\"children\":[[\"month\",\"05\",\"d\"],{\"children\":[[\"slug\",\"module-organization-guidelines-for\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7b1ec96690a919f5.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"__variable_7a8582 __variable_c4141f\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]}]]}],{\"children\":[[\"year\",\"2021\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$0:f:0:1:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"month\",\"05\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$0:f:0:1:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"module-organization-guidelines-for\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$0:f:0:1:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[\"$\",\"$L5\",null,{}]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"F3WTaI7RJi1GmFXeWsTF_\",{\"children\":[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:I[6704,[\"266\",\"static/chunks/870fdd6f-7cfe8e21d14519e7.js\",\"802\",\"static/chunks/69b09407-cf68df3e43abe457.js\",\"173\",\"static/chunks/173-63dfeb1b55f51a11.js\",\"291\",\"static/chunks/291-b0de5d611e0618a1.js\",\"729\",\"static/chunks/app/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D/page-35c7a06c65b3d5a6.js\"],\"default\"]\nf:T2b6a,"])</script><script>self.__next_f.push([1,"\u003cp\u003eThis post collects a random assortment of guidelines I commonly share for how to organize Haskell projects.\u003c/p\u003e\n\u003ch4\u003eOrganize modules “vertically”, not “horizontally”\u003c/h4\u003e\n\u003cp\u003eThe glib summary of this rule is: don’t create a “Types” or “Constants” module.\u003c/p\u003e\n\u003cp\u003e“Vertically” organized modules are modules that group related functionality within the same module. For example, vertically-oriented modules for a simple interpreter might be:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003eSyntax\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains the concrete syntax tree type and utilities for traversing, viewing, or editing that tree.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003eParsing\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains (or imports/re-exports) the parser type, a parser for the syntax tree, and error messages specific to parsing.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAn \u003ccode\u003eInfer\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains the the type inference logic, exception types, and error messages specific to type-checking.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAn \u003ccode\u003eEvaluation\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which logic for evaluating an expression, including possibly a separate data structure for a fully-evaluated abstract syntax tree.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003ePretty\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which specifies how to pretty-print or otherwise format expressions for display.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e“Horizontally” organized modules mean that you organize code into modules based on which language features or imports the code relies upon. For example, horizontally-oriented modules for the same interpreter might be:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003eTypes\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains almost all types, including the concrete syntax tree, abstract syntax tree, parsing-related types, and exception types.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003eLib\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains almost all functions, including the parsers, type inference code, evaluator, and prettyprinter.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ccode\u003eConstants\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains almost all constants (including all error messages, timeouts, and help text).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAn \u003ccode\u003eApp\u003c/code\u003e module\u003c/p\u003e\n\u003cp\u003e… which contains the \u003ccode\u003emain\u003c/code\u003e entry point for the program.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are a few reasons I prefer vertical module organization over horizontal module organization:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eVertically-organized modules are easier to split into smaller packages\u003c/p\u003e\n\u003cp\u003eFor example, in a vertically-organized project I could separate out the \u003ccode\u003eSyntax\u003c/code\u003e, \u003ccode\u003eParser\u003c/code\u003e, and \u003ccode\u003ePretty\u003c/code\u003e modules into a separate standalone package, which could be used by other people to create an automatic code formatter for my language without having to depend on the type-checking or evaluation logic.\u003c/p\u003e\n\u003cp\u003eConversely, there would be little benefit in separating out a \u003ccode\u003eTypes\u003c/code\u003e module from the equivalent horizontally-organized package. Typically, horizontal modules are so tightly coupled to one another that no subset of the modules is useful in isolation.\u003c/p\u003e\n\u003cp\u003eThe separability of vertical modules is an even bigger feature for proprietary projects that aspire to eventually open source their work. Vertically-organized projects are easier to open source a few modules at a time while keeping the proprietary pieces internal.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVertically-organized modules tend to promote more granular and incremental build graphs\u003c/p\u003e\n\u003cp\u003eIn a horizontally-organized project, each new type you add to the \u003ccode\u003eTypes\u003c/code\u003e module forces a rebuild of the entire package. In a vertically-organized project, if I completely rewrite the type-checking logic then only other modules that depend on type-checking will rebuild (and typically very few depend on type-checking).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVertically-organized modules tend to group related changes\u003c/p\u003e\n\u003cp\u003eA common issue in a horizontally-organized project is that every change touches almost every module, making new contributions harder and making related functionality more difficult to discover. In a vertically-organized project related changes tend to fall within the same module.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eNaming conventions\u003c/h4\u003e\n\u003cp\u003eI like to use the convention that the default module to import is the same as the package name, except replacing \u003ccode\u003e-\u003c/code\u003e with \u003ccode\u003e.\u003c/code\u003e and capitalizing words.\u003c/p\u003e\n\u003cp\u003eFor example, if your package name is \u003ccode\u003efoo-bar-baz\u003c/code\u003e, then the default module the user imports to use your package is \u003ccode\u003eFoo.Bar.Baz\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003ePackages following this module naming convention typically do not have module names beginning with \u003ccode\u003eControl.\u003c/code\u003e or \u003ccode\u003eData.\u003c/code\u003e prefixes (unless the package name happens to begin with a \u003ccode\u003econtrol-\u003c/code\u003e or \u003ccode\u003edata-\u003c/code\u003e prefix).\u003c/p\u003e\n\u003cp\u003eThere are a few reasons I suggest this convention:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eUsers can easily infer which module to import from the package name\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt tends to lead to shorter module names\u003c/p\u003e\n\u003cp\u003eFor example, the \u003ccode\u003eprettyprinter\u003c/code\u003e package recently switched to this idiom, which changed the default import from \u003ccode\u003eData.Text.Prettyprint.Doc\u003c/code\u003e to \u003ccode\u003ePrettyprinter\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt reduces module naming clashes between packages\u003c/p\u003e\n\u003cp\u003eThe reasoning is that you are already claiming global namespace when naming a package, so should why not also globally reserve the module of the same name, too?\u003c/p\u003e\n\u003cp\u003eHowever, this won’t completely eliminate the potential for name clashes for other non-default modules that your package exports.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eThe “God” library stanza\u003c/h4\u003e\n\u003cp\u003eThis is a tip \u003cstrong\u003efor proprietary projects only\u003c/strong\u003e: put all of your project’s code into one giant library stanza in your \u003ccode\u003e.cabal\u003c/code\u003e file, including the entrypoint logic (like your command-line interface), tests, and benchmarks. Then every other stanza in the \u003ccode\u003e.cabal\u003c/code\u003e file (i.e. the executables, test suites, and benchmarks) should just be a thin wrapper around something exported from one of your “library” modules.\u003c/p\u003e\n\u003cp\u003eFor example, suppose that your package is named \u003ccode\u003efoo\u003c/code\u003e which builds an executable named \u003ccode\u003ebar\u003c/code\u003e. Your \u003ccode\u003efoo.cabal\u003c/code\u003e file would look like this (with only the relevant parts shown):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: foo\n…\n\nlibrary\n  hs-source-dirs: src\n  exposed-modules:\n    Foo.Bar\n  …\n\nexecutable bar\n  hs-source-dirs: bar\n  main-is: Main.hs\n  …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e… where \u003ccode\u003esrc/Foo/Bar.hs\u003c/code\u003e would look like this:\u003c/p\u003e\n\u003cpre class=\"shiki catppuccin-frappe\" style=\"background-color:#303446;color:#c6d0f5\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e-- ./src/Foo/Bar.hs\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#CA9EE6\"\u003emodule\u003c/span\u003e\u003cspan style=\"color:#E5C890\"\u003e Foo.Bar\u003c/span\u003e\u003cspan style=\"color:#CA9EE6\"\u003e where\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#81C8BE\"\u003e…\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#8CAAEE;font-style:italic\"\u003emain\u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e ::\u003c/span\u003e\u003cspan style=\"color:#CA9EE6\"\u003e IO\u003c/span\u003e\u003cspan style=\"color:#949CBB\"\u003e ()\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#C6D0F5\"\u003emain \u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e …\u003c/span\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e -- Your real `main` goes here\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e… and \u003ccode\u003ebar/Main.hs\u003c/code\u003e is a trivial wrapper around \u003ccode\u003eFoo.Bar.main\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"shiki catppuccin-frappe\" style=\"background-color:#303446;color:#c6d0f5\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e-- ./bar/Main.hs\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#CA9EE6\"\u003emodule\u003c/span\u003e\u003cspan style=\"color:#E5C890\"\u003e Main\u003c/span\u003e\u003cspan style=\"color:#CA9EE6\"\u003e where\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#CA9EE6\"\u003eimport\u003c/span\u003e\u003cspan style=\"color:#CA9EE6\"\u003e qualified\u003c/span\u003e\u003cspan style=\"color:#E5C890\"\u003e Foo.Bar\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#8CAAEE;font-style:italic\"\u003emain\u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e ::\u003c/span\u003e\u003cspan style=\"color:#CA9EE6\"\u003e IO\u003c/span\u003e\u003cspan style=\"color:#949CBB\"\u003e ()\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#C6D0F5\"\u003emain \u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#E5C890\"\u003e Foo.Bar.\u003c/span\u003e\u003cspan style=\"color:#C6D0F5\"\u003emain\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tip specifically works around \u003ccode\u003ecabal repl\u003c/code\u003e’s poor support for handling changes that span multiple project stanzas (both \u003ccode\u003ecabal v1-repl\u003c/code\u003e and \u003ccode\u003ecabal v2-repl\u003c/code\u003e appear to have the problem).\u003c/p\u003e\n\u003cp\u003eTo illustrate the issue, suppose that you use \u003ccode\u003ecabal repl\u003c/code\u003e to load the executable logic for the project like this:\u003c/p\u003e\n\u003cpre class=\"shiki catppuccin-frappe\" style=\"background-color:#303446;color:#c6d0f5\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#8CAAEE;font-style:italic\"\u003e$\u003c/span\u003e\u003cspan style=\"color:#A6D189\"\u003e cabal\u003c/span\u003e\u003cspan style=\"color:#A6D189\"\u003e repl\u003c/span\u003e\u003cspan style=\"color:#A6D189\"\u003e exe:bar\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#8CAAEE;font-style:italic\"\u003e…\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color:#81C8BE\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#C6D0F5\"\u003eMain\u003c/span\u003e\u003cspan style=\"color:#81C8BE\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow if you change the \u003ccode\u003eFoo.Bar\u003c/code\u003e module and \u003ccode\u003e:reload\u003c/code\u003e the REPL, the REPL will not reflect the changes you made. This is a pain whenever you need to test changes that span your library and an executable, your library and a test suite, or your library and a benchmark.\u003c/p\u003e\n\u003cp\u003eAlso, if you load an executable / test suite / benchmark into the REPL that depends on a separate library stanza then \u003ccode\u003ecabal repl\u003c/code\u003e will force you to generate object code for the library stanza, which is slow. Contrast that with using \u003ccode\u003ecabal repl\u003c/code\u003e to only load the library stanza, which will be faster because it won’t generate object code.\u003c/p\u003e\n\u003cp\u003eMoreover, \u003ccode\u003eghcid\u003c/code\u003e uses \u003ccode\u003ecabal repl\u003c/code\u003e to power its fast type-checking loop, which means that \u003ccode\u003eghcid\u003c/code\u003e also does not work well if you need to quickly switch between changes to the library stanza and other project stanzas.\u003c/p\u003e\n\u003cp\u003eThe fix to all of these problems is: put all of your project’s logic into the library stanza and use only the library stanza as basis for your interactive development. Everything else (your executables, your test suites, and your benchmarks) is just a trivial wrapper around something exported from the library.\u003c/p\u003e\n\u003cp\u003eI don’t recommend this solution for open source projects, though. If you do this for a public package then your end users will hate you because your package’s library section will depend on test packages or benchmarking packages that can’t be disabled. In contrast, proprietary codebases rarely care about gratuitous dependencies (in my experience).\u003c/p\u003e\n\u003ch4\u003eConclusion\u003c/h4\u003e\n\u003cp\u003eThose are all of the tips I can think of at the moment. Leave a comment if you think I missed another common practice.\u003c/p\u003e"])</script><script>self.__next_f.push([1,"6:[\"$\",\"$Le\",null,{\"title\":\"Module organization guidelines for Haskell projects\",\"date\":\"Wednesday, May 19, 2021\",\"content\":\"$f\",\"year\":\"2021\"}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Haskell for all: Module organization guidelines for Haskell projects\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Tips and tricks for how to organize a Haskell project\"}],[\"$\",\"link\",\"3\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"title\":\"Haskell for all\",\"href\":\"https://haskellforall.com/rss.xml\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Module organization guidelines for Haskell projects\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"Tips and tricks for how to organize a Haskell project\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://haskellforall.com/imgs/logo.jpg\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:alt\",\"content\":\"Module organization guidelines for Haskell projects\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:title\",\"content\":\"Module organization guidelines for Haskell projects\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:description\",\"content\":\"Tips and tricks for how to organize a Haskell project\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:image\",\"content\":\"https://haskellforall.com/imgs/logo.jpg\"}],[\"$\",\"link\",\"13\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"24x24\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script></body></html>